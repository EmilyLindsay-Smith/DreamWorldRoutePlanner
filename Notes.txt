#Algorithm Choices



Dijkstra 
	- gives path to all nodes which is useful information for the getting nearest utility
	- don't need to worry about negative weight in this context
	- Dijkstra with Adj Matrix = time O(v^2), space O(v^2)
	- Dijkstra with Adj List = O(E logV)
		- insertion & extraction in priority queue = O(V log V)
		- once extracted, iterate and update priority queue - each edge explored once .: updating queue is O(log V) .: overall O(E logV)
		- need to use Heap/Priority Queue : binary heap needed
			-std::priority_queue can't decrease key - therefore suggest adding more copies of it
				- still only consider instance wiht min dist
		- with these optimisations, gets the same worst-case perforamcne but retrieves more data 
adjList: could be map<map> again, or list<pair<weight,node>> 

SPACE COMPLEXITY: O(V+E)

priority_queue pq;
vector<int> dist(numVertices, INF);
pq.push((0,src));
dist[src] = 0;

while (!pq.empty()){
	int u = pq.top().second(); //where dist is .first,
	pq.pop();
	list<pair<int,int>>::iterator i;
	for (i=adj[u].being();i!=adj[u].end();i++){ // for el in adjList
		int v = (*i).first; //get curr adjacent vertex
		int weight = (*i).second;
		if (dist[v] > dist[u] + weight){
			dist[v] = dist[u] + weight;
			pq.push(dist[v], v));
		}
	}
}
print distances stored in dist

SPACE COMPLEXITY: O(V)
	- f : flag array to store vertices extracted from priority queue to avoid updating weights of already extracted items

Choice of flag array is faster O(1) than Hashset amoritised O(1)

If range of edge weights is small, could go for Dial's algorithm with time compleixty O(V*W) where V is numv Vert and W is max edge weight; O(V*W) space complexity
Better when range of edge weights is small .: only take small num distinct values
	- assumes all edge weights are integers and max edge weight is fixed

PRIM ALGORITHM
	- better than Kruskal if graph is dense (as this is) as more efficient with dense graphs; don't need to manage disconnected graphs here 
	- if adjMatrix, time complexity = O(V2)
	- if adjList, time complexity = O(E*logV) with binary heap, aux space o(V)
	In theory, O(E + logV) if Fibonacci heap used but in practice this can take longer due to constants 

PREFIX TREE
Creation/Search: O(W*L) where W = num words and L = average word length
Similar in practice to HashMap BUT can search by substrings
Smaller footprint & complexity to suffix tree?
Could be further improved as radix tree

Could create a naive suffix tree based on this if add word word-length times, and make stringRef a vector - in collecting words, rather than concatenating transitions, just follow to leaf and get string from the settlement pointer
	- may need to return sets to avoid duplications


































